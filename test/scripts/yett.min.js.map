{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isOnBlacklist = (src, type) => (\n    src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    isBlacklistedSource(src)\n)\n\nexport const isBlacklistedSource = function(src) {\n  const srcStart = src === undefined ? \"\" : src.split(\"?\")[0];\n  return srcStart &&\n  (\n    (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(srcStart))) &&\n    (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(srcStart)))\n  )\n}\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}","export const TYPE_ATTRIBUTE = 'javascript/blocked'\nexport const HIDDEN_SRC_ATTRIBUTE = 'yett-src'\n\n\nexport const patterns = {\n    blacklist: window.YETT_BLACKLIST,\n    whitelist: window.YETT_WHITELIST\n}\n\n// Backup list containing the original blacklisted elements\nexport const backupElements = {\n    blacklisted: []\n}","import { backupElements, TYPE_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'SCRIPT') {\n                const src = node.src\n                const type = node.type\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup the node\n                    backupElements.blacklisted.push([node, node.type])\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    node.parentElement && node.parentElement.removeChild(node)\n                }\n            }\n        }\n    }\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","import { TYPE_ATTRIBUTE, HIDDEN_SRC_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst createElementBackup = document.createElement\n\nconst originalDescriptors = {\n    script: {\n      class: HTMLScriptElement,\n      src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n      type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n    },\n    iframe: {\n      class: HTMLIFrameElement,\n      src: Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'src'),\n      type: Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'type')\n    }\n}\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a patched tag, bypass\n    const tagName = args[0].toLowerCase()\n    const descriptors = originalDescriptors[tagName]\n    if(descriptors === undefined)\n        return createElementBackup.bind(document)(...args)\n\n    const mockElt = createElementBackup.bind(document)(...args)\n\n    // Define getters / setters to ensure that the script type is properly set\n    try {\n        Object.defineProperties(mockElt, {\n            'src': {\n                get() {\n                    return descriptors.src.get.call(this)\n                },\n                set(value) {\n                    if(isOnBlacklist(value, mockElt.type)) {\n                        if (descriptors.type) {\n                          descriptors.type.set.call(this, TYPE_ATTRIBUTE)\n                        } else {\n                          descriptors.class.prototype.setAttribute.call(this, HIDDEN_SRC_ATTRIBUTE, value)\n                          value = undefined\n                        }\n                    }\n\n                    if(value !== undefined)\n                      descriptors.src.set.call(this, value)\n                }\n            },\n            'type': {\n                set(value) {\n                    const typeValue = isOnBlacklist(mockElt.src, mockElt.type) ? TYPE_ATTRIBUTE : value\n                    descriptors.type.set.call(this, typeValue)\n                }\n            }\n        })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        mockElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src') {\n                mockElt[name] = value\n            } else\n                descriptors.class.prototype.setAttribute.call(mockElt, name, value)\n        }\n    } catch (error) {\n        // eslint-disable-next-line\n        console.warn(\n            'Yett: unable to prevent script execution for ' + tagName + ' src ', mockElt.src, '.\\n',\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\n        )\n    }\n    return mockElt\n}","import {\n    patterns,\n    backupElements,\n    TYPE_ATTRIBUTE,\n    HIDDEN_SRC_ATTRIBUTE\n} from './variables'\n\nimport {\n    willBeUnblocked\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrlsOrRegexes) {\n    if(scriptUrlsOrRegexes.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = []\n    } else {\n        if(patterns.blacklist) {\n            patterns.blacklist = patterns.blacklist.filter(pattern => (\n                scriptUrlsOrRegexes.every(urlOrRegexp => {\n                    if(typeof urlOrRegexp === 'string')\n                        return !pattern.test(urlOrRegexp)\n                    else if(urlOrRegexp instanceof RegExp)\n                        return pattern.toString() !== urlOrRegexp.toString()\n                })\n            ))\n        }\n        if(patterns.whitelist) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrlsOrRegexes\n                    .map(urlOrRegexp => {\n                        if(typeof urlOrRegexp === 'string') {\n                            const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                            const permissiveRegexp = '.*' + escapedUrl + '.*'\n                            if(patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\n                                return new RegExp(permissiveRegexp)\n                            }\n                        } else if(urlOrRegexp instanceof RegExp) {\n                            if(patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\n                                return urlOrRegexp\n                            }\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n\n    // Parse existing tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"], *[${HIDDEN_SRC_ATTRIBUTE}]`)\n    for(let i = 0; i < tags.length; i++) {\n        const elem = tags[i]\n        if(willBeUnblocked(elem)) {\n            backupElements.blacklisted.push([elem, 'application/javascript'])\n            elem.parentElement.removeChild(elem)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupElements.blacklisted].forEach(([elem, type], index) => {\n        if(willBeUnblocked(elem)) {\n            const tagName = elem.tagName.toLowerCase();\n            const elementNode = document.createElement(tagName)\n            const stashedSrc = elem.getAttribute(HIDDEN_SRC_ATTRIBUTE);\n            if (stashedSrc) {\n                console.log('Unstashing', stashedSrc);\n                elementNode.setAttribute('src', stashedSrc)\n            } else {\n                console.log('resetting', elem.src);\n                elementNode.setAttribute('type', type || 'application/javascript')\n                elementNode.setAttribute('src', elem.src)\n            }\n\n            for(let key in elem) {\n                if(key.startsWith(\"on\")) {\n                    elementNode[key] = elem[key]\n                }\n            }\n            document.head.appendChild(elementNode)\n            backupElements.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\n        observer.disconnect()\n    }\n}"],"names":["isOnBlacklist","src","type","TYPE_ATTRIBUTE","isBlacklistedSource","willBeUnblocked","script","getAttribute","patterns","blacklist","every","entry","test","whitelist","some","HIDDEN_SRC_ATTRIBUTE","window","YETT_BLACKLIST","YETT_WHITELIST","backupElements","blacklisted","srcStart","undefined","split","pattern","observer","MutationObserver","mutations","i","length","addedNodes","node","nodeType","tagName","push","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","parentElement","removeChild","observe","document","documentElement","childList","subtree","createElementBackup","createElement","originalDescriptors","HTMLScriptElement","Object","getOwnPropertyDescriptor","prototype","iframe","HTMLIFrameElement","args","toLowerCase","descriptors","bind","mockElt","defineProperties","get","call","this","set","value","setAttribute","typeValue","name","error","console","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","toString","map","permissiveRegexp","replace","p","Boolean","tags","querySelectorAll","elem","indexOffset","forEach","index","elementNode","stashedSrc","key","log","startsWith","head","appendChild","splice","disconnect"],"mappings":"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"}