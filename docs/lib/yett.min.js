(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.yett = {})));
}(this, (function (exports) { 'use strict';

  const TYPE_ATTRIBUTE = 'javascript/blocked';

  const patternsObj = {
      blacklist: null,
      whitelist: null
  };

  const patterns = {
      blacklist:  window.YETT_BLACKLIST,
      whitelist:  window.YETT_WHITELIST,
      tags: []
  };

  if (patterns.blacklist){
    patterns.blacklist.forEach(element => {
      if (typeof element === 'string'){
          const pos = element.indexOf('/');
          if (pos > 1) {
              const tag = element.substring(0,pos);
              if (tag.length > 1)
                  patterns.tags.push(tag);
          }
      }
    });
  }

  if (! (patterns.blacklist instanceof Array) && (patterns.blacklist instanceof Object)){
      patternsObj.blacklist = patterns.blacklist;
      patterns.blacklist = Object.keys(patternsObj.blacklist);
  }
  if (! (patterns.whitelist instanceof Array) && (patterns.whitelist instanceof Object)){
      patternsObj.whitelist = patterns.whitelist;
      patterns.whitelist = Object.keys(patternsObj.whitelist);
      
  } 
  // Backup list containing the original blacklisted script elements
  const backupScripts = {
      blacklisted: []
  };

  const blockNodeNoBackup = (node,blockingType) => {

      if(typeof blockingType === "string" && blockingType != "remove"){
          let arr = blockingType.split(":");
          let type = 'src';
          let value = null;
          if(arr.length < 1){
              value = arr[0];
          }else{
              type = arr[0];
              value = arr[1];
          }
          if (type == 'javascript'){
              eval(value);
          }else{
              node[type] = value;
          }
          return true
      }
      return false
  };

  const blockNode = (node,blockingType) => {
      const parent = node.parentElement;
      if (!parent)
          return false
      backupScripts.blacklisted.push([node.cloneNode(),parent]);
      if (blockingType === true || blockingType === 'remove'){
          parent.removeChild(node);
          return true
      }
      return blockNodeNoBackup(node,blockingType)
  };

  /*
  * pattern: tagName:attribute/expresion/blockingType
  * node: an html node or a string with an url or a string to evaluate pattern: tagName:attribute/expresion/ 
  *       (las expression must end on /) 
  */
  const testPattern = (pattern,node) => {
      if(typeof node === "string"){
          if ( !node.startsWith('http') && node.slice(-1) == '/'){
              const pos = node.indexOf('/');
              const posEnd = node.indexOf('/',pos+1);
              const value = node.substring(pos+1,posEnd-1);
              let type = 'src';
              let tagName = 'SCRIPT';
              if(pos != 0){
                  let arr_type = node.substring(0,pos).split(":");
                  if (arr_type.length > 1){
                      type = arr_type[1];
                      tagName = arr_type[0].toUpperCase();
                  }else{
                      type = arr_type[0];
                  }
              }
              node = {'tagName': tagName};
              node[type]=value;           
          }else{
              node = {'src': node, 'tagName': 'SCRIPT'};
          }
      }
      if (! (typeof pattern === "string")){
          if (node.tagName === "SCRIPT" && node.src)
              return pattern.test(node.src)
          else
              return false
      }
      const pos = pattern.indexOf('/');
      const posEnd = pattern.indexOf('/',pos+1);
      let blockingType = pattern.substring(posEnd+1);    
      let type = 'src';
      let tagName = null;
      if(pos != 0){
          let arr_type = pattern.substring(0,pos).split(":");
          if (arr_type.length > 1){
              type = arr_type[1];
              tagName = arr_type[0].toUpperCase();
          }else{
              type = arr_type[0];
          }
      }
      if (tagName && tagName !== node.tagName) return false;
      if (blockingType.length < 1 )
          blockingType = true;
      pattern = pattern.substring(pos,posEnd+1);
      if (!node[type]){
          if (pattern == '//') return blockingType
          else return false
      }
      return eval(pattern).test(node[type]) ? blockingType : false
  };
  /*
  *   blockingType
  *   Returns false if not blocked, true if default blocking type (delete node),or blocking type in rule
  *   whith '//' pattern can block local scripts:
  *   - false
  *   - true or remove
  *   - attribute:value
  *   - javascript:function whith node as parameter
  */
  const isOnBlacklist = (node) => {
      let blockingType = false;
      
      if (node.type && node.type === TYPE_ATTRIBUTE) return true;

      if (patterns.blacklist){
          blockingType =  patterns.blacklist.some(pattern => testPattern(pattern,node));
      }

      if (patterns.whitelist){
          blockingType =  patterns.whitelist.every(pattern => !testPattern(pattern,node));
      }    

      return blockingType

  };

  const willBeUnblocked = function(script) {
      // const src = script.getAttribute('src')
      return (
          patterns.blacklist && patterns.blacklist.every(entry => !testPattern(entry,script)) ||
          patterns.whitelist && patterns.whitelist.some(entry => testPattern(entry,script))
      )
  };

  // Setup a mutation observer to track DOM insertion
  const observer = new MutationObserver(mutations => {
      mutations.forEach(({ addedNodes }) => {
          for(let i = 0; i < addedNodes.length; i++) {
              const node = addedNodes[i];
              // For each added script tag
              if(node.nodeType === 1 ){
                  const blockingType = isOnBlacklist(node);                 
                  if (node.tagName === 'SCRIPT') {
                      const src = node.src;
                      const type = node.type;
                      // If the src is inside the blacklist and is not inside the whitelist

                      if(blockingType) {
                          // We backup a copy of the script node
                          backupScripts.blacklisted.push([node.cloneNode(),node.parentElement]);
                          blockNodeNoBackup(node,blockingType);
                          // Blocks inline script execution in Safari & Chrome
                          node.type = TYPE_ATTRIBUTE;

                          // Firefox has this additional event which prevents scripts from beeing executed
                          const beforeScriptExecuteListener = function (event) {
                              // Prevent only marked scripts from executing
                              if(node.getAttribute('type') === TYPE_ATTRIBUTE)
                                  event.preventDefault();
                              node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener);
                          };
                          node.addEventListener('beforescriptexecute', beforeScriptExecuteListener);
                          
                          node.parentElement.removeChild(node);
                      }
                  }
                  else if (blockingType) {
                      // Remove the node from the DOM
                      blockNode(node,blockingType);
                  }
                  // if(node.nodeType === 1 && node.tagName === 'IFRAME' && TYPE_SANDBOX !== false) {
                  //     const src = node.src
                  //     // If the src is inside the blacklist and is not inside the whitelist
                  //     if(isOnBlacklist(src)) {
                  //         // We backup a copy of the script node
                  //         //backupIframes.blacklisted.push(node.cloneNode())

                  //         if (TYPE_SANDBOX === 'remove'){
                  //             // Remove the node from the DOM
                  //             node.parentElement.removeChild(node)
                  //         }else{
                  //             node.sandbox = TYPE_SANDBOX
                  //         }
                  //     }
                  // }  
              }          
          }
      });
  });

  // Starts the monitoring
  observer.observe(document.documentElement, {
      childList: true,
      subtree: true
  });

  const originalDescriptors = {
      src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),
      type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')
  };
  const createElementBackup = document.createElement;

  // Monkey patch the createElement method to prevent dynamic scripts from executing
  document.createElement = function(...args) {

      const tag = args[0].toLowerCase(); 
      const nodeElt = createElementBackup.bind(document)(...args);

      if(tag === 'script'){
          // Use the prototype descriptors
              Object.defineProperties(nodeElt, {
                  'src': {
                      get() {
                          return originalDescriptors.src.get.call(this)
                      },
                      set(value) {
                          if(isOnBlacklist({'src':value,'type':nodeElt.type})) {
                              nodeElt.backup_type = nodeElt.type;
                              nodeElt.type = TYPE_ATTRIBUTE;
                          }
                          return originalDescriptors.src.set.call(this, value)
                      }
                  },
                  'type': {
                      set(value) {
                          const blockingType = isOnBlacklist(nodeElt);
                          if (blockingType) nodeElt.backup_type = value;
                          return originalDescriptors.type.set.call(
                              this,
                              blockingType ?
                                  TYPE_ATTRIBUTE :
                                  value
                          )
                      }
                  }
              });

          // Monkey patch the setAttribute function so that the setter is called instead
          nodeElt.setAttribute = function(name, value) {
              if(name === 'type' || name === 'src')
                  nodeElt[name] = value;
              else
                  HTMLScriptElement.prototype.setAttribute.call(nodeElt, name, value);
          };

      }   

      if (patterns.tags.some(element => (tag === element[0]))){
          let props={ };
          props[patterns.tags[tag]]={
                  get() {
                      return originalDescriptors.src.get.call(this)
                  },
                  set(value) {
                      if(isOnBlacklist(nodeElt)) {
                          nodeElt.backup_type = nodeElt.type;
                          nodeElt.type = TYPE_ATTRIBUTE;
                      }
                      return originalDescriptors.src.set.call(this, value)
                  }
          };
          Object.defineProperties(nodeElt, props);

          // Monkey patch the setAttribute function so that the setter is called instead
          nodeElt.setAttribute = function(name, value) {
              if(name === tag)
                  nodeElt[name] = value;
              else
                  HTMLScriptElement.prototype.setAttribute.call(nodeElt, name, value);
          };        
      }
      if (!blockNodeNoBackup(nodeElt)) nodeElt.style = 'display:none';

      return nodeElt
  };

  const URL_REPLACER_REGEXP = new RegExp('[|\\{}()[\\]^$+*?.]', 'g');

  const unblockId = function(...scriptIds) {
      scriptIds.forEach((e) => {
          if (patternsObj.blacklist instanceof Object){
              try{
                  unblock(patternsObj.blacklist[e]);
              }catch(_){  /* do nothing*/     }
          }
          if (patternsObj.whitelist instanceof Object){
              try{
                  unblock(patternsObj.whitelist[e]);
              }catch(_){ /* do nothing*/  }
          }        
      });
  };

  // Unblocks all (or a selection of) blacklisted scripts.
  const unblock = function(...scriptUrls) {

      if(scriptUrls.length < 1) {
          patterns.blacklist = [];
          patterns.whitelist = [];
      } else {
          if(patterns.blacklist instanceof Array) {
              patterns.blacklist = patterns.blacklist.filter(pattern =>
                  scriptUrls.every(url => !testPattern(pattern,url))
              );
          }
          if(patterns.whitelist instanceof Array) {
              patterns.whitelist = [
                  ...patterns.whitelist,
                  ...scriptUrls
                      .map(url => {
                          const escapedUrl = url.replace(URL_REPLACER_REGEXP, '\\$&');
                          const permissiveRegexp = '.*' + escapedUrl + '.*';
                          if(!patterns.whitelist.find(p => p.toString() === permissiveRegexp.toString())) {
                              return new RegExp(permissiveRegexp)
                          }
                          return null
                      })
                      .filter(Boolean)
              ];
          }
      }

      // Parse existing script tags with a marked type
      const tags = document.querySelectorAll(`script[type="${TYPE_ATTRIBUTE}"]`);
      for(let i = 0; i < tags.length; i++) {
          const script = tags[i];
          if(willBeUnblocked(script)) {
              script.type = 'application/javascript';
              backupScripts.blacklisted.push([script,script.parentElement]);
              script.parentElement.removeChild(script);
          }
      }

      // Exclude 'whitelisted' scripts from the blacklist and append them to <head>
      let indexOffset = 0;
      [...backupScripts.blacklisted].forEach((arr, index) => {
          let script = arr[0];
          let parent = arr[1];
          if(willBeUnblocked(script)) {
              if (script.type && script.type === TYPE_ATTRIBUTE)
                  script.type = 'application/javascript';
              parent.appendChild(script);
              backupScripts.blacklisted.splice(index - indexOffset, 1);
              indexOffset++;
          }
      });    

      // Disconnect the observer if the blacklist is empty for performance reasons
      if(patterns.blacklist && patterns.blacklist.length < 1) {
          observer.disconnect();
      }
  };

  exports.unblock = unblock;
  exports.unblockId = unblockId;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=yett.min.js.map
