{"version":3,"file":"yett.min.js","sources":["../../src/variables.js","../../src/checks.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["export const TYPE_ATTRIBUTE = 'javascript/blocked'\n\nexport const TYPE_SANDBOX = window.TYPE_SANDBOX \n\nexport const patternsObj = {\n    blacklist: null,\n    whitelist: null\n}\n\nexport const patterns = {\n    blacklist:  window.YETT_BLACKLIST,\n    whitelist:  window.YETT_WHITELIST\n}\n\nif (! (patterns.blacklist instanceof Array) && (patterns.blacklist instanceof Object)){\n    patternsObj.blacklist = patterns.blacklist;\n    patterns.blacklist = Object.keys(patternsObj.blacklist);\n}\nif (! (patterns.whitelist instanceof Array) && (patterns.whitelist instanceof Object)){\n    patternsObj.whitelist = patterns.whitelist;\n    patterns.whitelist = Object.keys(patternsObj.whitelist);\n    \n} \n// Backup list containing the original blacklisted script elements\nexport const backupScripts = {\n    blacklisted: []\n}\nexport const backupIframes = {\n    blacklisted: []\n}","import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isOnBlacklist = (src, type) => (\n    src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    (\n        (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(src))) &&\n        (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(src)))\n    )\n)\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}","import { backupScripts, backupIframes, TYPE_ATTRIBUTE, TYPE_SANDBOX } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    mutations.forEach(({ addedNodes }) => {\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'SCRIPT') {\n                const src = node.src\n                const type = node.type\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup a copy of the script node\n                    backupScripts.blacklisted.push(node.cloneNode())\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    node.parentElement.removeChild(node)\n                }\n            }\n            if(node.nodeType === 1 && node.tagName === 'IFRAME' && TYPE_SANDBOX !== false) {\n                const src = node.src\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src)) {\n                    // We backup a copy of the script node\n                    backupIframes.blacklisted.push(node.cloneNode())\n\n                    if (TYPE_SANDBOX === 'remove'){\n                        // Remove the node from the DOM\n                        node.src = \"\"\n                    }else{\n                        node.sandbox = TYPE_SANDBOX\n                    }\n                }\n            }            \n        }\n    })\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","import { TYPE_ATTRIBUTE,TYPE_SANDBOX } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst originalDescriptors = {\n    src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n    type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n}\nconst createElementBackup = document.createElement\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a script tag, bypass\n\n    if(args[0].toLowerCase() === 'iframe' && TYPE_SANDBOX !== false){\n        if (TYPE_SANDBOX === 'remove'){\n            return null;\n        }\n        const scriptElt = createElementBackup.bind(document)(...args)\n\n        // Use the prototype descriptors\n        Object.defineProperties(scriptElt, {\n            'src': {\n                get() {\n                    return originalDescriptors.src.get.call(this)\n                },\n                set(value) {\n                    if(isOnBlacklist(value, scriptElt.type)) {\n                        scriptElt.sandbox = TYPE_SANDBOX\n                    }\n                    return originalDescriptors.src.set.call(this, value)\n                }\n            },\n            'sandbox': {\n                set(value) {\n                    return originalDescriptors.type.set.call(\n                        this,\n                        isOnBlacklist(scriptElt.src) ?\n                            TYPE_SANDBOX :\n                            value\n                    )\n                }\n            }\n        })\n    \n        // Monkey patch the setAttribute function so that the setter is called instead\n        scriptElt.setAttribute = function(name, value) {\n            if(name === 'sandbox' || name === 'src')\n                scriptElt[name] = value\n            else\n                HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n        }\n    \n        return scriptElt\n    }\n\n    if(args[0].toLowerCase() !== 'script')\n        return createElementBackup.bind(document)(...args)\n\n    const scriptElt = createElementBackup.bind(document)(...args)\n\n    // Use the prototype descriptors\n    Object.defineProperties(scriptElt, {\n        'src': {\n            get() {\n                return originalDescriptors.src.get.call(this)\n            },\n            set(value) {\n                if(isOnBlacklist(value, scriptElt.type)) {\n                    scriptElt.type = TYPE_ATTRIBUTE\n                }\n                return originalDescriptors.src.set.call(this, value)\n            }\n        },\n        'type': {\n            set(value) {\n                return originalDescriptors.type.set.call(\n                    this,\n                    isOnBlacklist(scriptElt.src, scriptElt.type) ?\n                        TYPE_ATTRIBUTE :\n                        value\n                )\n            }\n        }\n    })\n\n    // Monkey patch the setAttribute function so that the setter is called instead\n    scriptElt.setAttribute = function(name, value) {\n        if(name === 'type' || name === 'src')\n            scriptElt[name] = value\n        else\n            HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n    }\n\n    return scriptElt\n}","import {\n    patterns,\n    backupScripts,\n    TYPE_ATTRIBUTE,\n    patternsObj\n} from './variables'\n\nimport {\n    willBeUnblocked\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\nexport const unblockId = function(...scriptIds) {\n    scriptIds.forEach((e) => {\n        if (patternsObj.blacklist instanceof Object){\n            try{\n                unblock(patternsObj.blacklist[e]);\n            }catch(_){  /* do nothing*/     }\n        }\n        if (patternsObj.whitelist instanceof Object){\n            try{\n                unblock(patternsObj.whitelist[e]);\n            }catch(_){ /* do nothing*/  }\n        }        \n    });\n}\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrls) {\n\n    if(scriptUrls.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = []\n    } else {\n        if(patterns.blacklist instanceof Array) {\n            patterns.blacklist = patterns.blacklist.filter(pattern =>\n                scriptUrls.every(url => !pattern.test(url))\n            )\n        }\n        if(patterns.whitelist instanceof Array) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrls\n                    .map(url => {\n                        const escapedUrl = url.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                        const permissiveRegexp = '.*' + escapedUrl + '.*'\n                        if(!patterns.whitelist.find(p => p.toString() === permissiveRegexp.toString())) {\n                            return new RegExp(permissiveRegexp)\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n    // Parse existing script tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < tags.length; i++) {\n        const script = tags[i]\n        if(willBeUnblocked(script)) {\n            script.type = 'application/javascript'\n            backupScripts.blacklisted.push(script)\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupScripts.blacklisted].forEach((script, index) => {\n        if(willBeUnblocked(script)) {\n            const scriptNode = document.createElement('script')\n            scriptNode.setAttribute('src', script.src)\n            scriptNode.setAttribute('type', 'application/javascript')\n            document.head.appendChild(scriptNode)\n            backupScripts.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\n        observer.disconnect()\n    }\n}"],"names":["TYPE_SANDBOX","window","patternsObj","patterns","YETT_BLACKLIST","YETT_WHITELIST","blacklist","Array","Object","keys","whitelist","backupScripts","backupIframes","isOnBlacklist","src","type","some","pattern","test","every","willBeUnblocked","script","getAttribute","entry","observer","MutationObserver","forEach","addedNodes","i","node","nodeType","tagName","blacklisted","push","cloneNode","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","parentElement","removeChild","sandbox","length","observe","document","documentElement","originalDescriptors","getOwnPropertyDescriptor","HTMLScriptElement","prototype","createElementBackup","createElement","args","toLowerCase","scriptElt","bind","defineProperties","get","call","this","value","set","setAttribute","name","URL_REPLACER_REGEXP","RegExp","unblock","scriptUrls","filter","url","map","permissiveRegexp","replace","find","p","toString","Boolean","tags","querySelectorAll","indexOffset","index","scriptNode","head","appendChild","splice","disconnect","scriptIds","e","_"],"mappings":"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"}