{"version":3,"file":"yett.min.js","sources":["../../src/variables.js","../../src/checks.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["\nexport const TYPE_ATTRIBUTE = 'javascript/blocked'\n\nexport const jsonStringify = value => {\n    return JSON.stringify(value,replacer,2)\n}\nexport const jsonParse = value => {\n    return JSON.parse(value,reviver) \n}\n\nexport const patternsObj = {\n    blacklist: null,\n    whitelist: null\n}\n\nexport const patterns = {\n    blacklist:  window.localStorage.YETT_BLACKLIST ? jsonParse(window.localStorage.YETT_BLACKLIST) : window.YETT_BLACKLIST,\n    whitelist:  window.localStorage.YETT_WHITELIST ? jsonParse(window.localStorage.YETT_WHITELIST) : window.YETT_WHITELIST,\n    tags: []\n}\n\n\n\nif (! (patterns.blacklist instanceof Array) && (patterns.blacklist instanceof Object)){\n    patternsObj.blacklist = patterns.blacklist;\n    patterns.blacklist = Object.values(patternsObj.blacklist);\n}\nif (! (patterns.whitelist instanceof Array) && (patterns.whitelist instanceof Object)){\n    patternsObj.whitelist = patterns.whitelist;\n    patterns.whitelist = Object.values(patternsObj.whitelist);\n    \n} \n\nif (patterns.blacklist){\n    patterns.blacklist.forEach(element => {\n      if (typeof element === 'string'){\n          const pos = element.indexOf('/')\n          if (pos > 1) {\n              const tag = element.substring(0,pos)\n              if (tag.length > 1)\n                  patterns.tags.push(tag)\n          }\n      }\n    })\n  }\n\n// Backup list containing the original blacklisted script elements\nexport const backupScripts = {\n    blacklisted: []\n}\n\nexport const blockNodeNoBackup = (node,blockingType,attribute) => {\n\n    if(typeof blockingType === \"string\" && blockingType != \"remove\"){\n        let arr = blockingType.split(\":\")\n        let type = 'src'\n        let value = null\n        if(arr.length < 1){\n            value = arr[0]\n        }else{\n            type = arr[0]\n            value = arr[1]\n        }\n        if(!type)\n            type = 'src'\n        if(type.startsWith('_backup_') || type == 'type' )\n            return false\n        if (node['type'] != TYPE_ATTRIBUTE){\n            node['_backup_type'] = node['type'] \n            node['type'] = TYPE_ATTRIBUTE\n        }           \n        if (type == 'javascript'){\n            eval(value)          \n        }else{\n            node['_backup_'+type] = node[type]\n            if (attribute === type)\n                return value\n            else\n                node[type] = value\n        }       \n        return true\n    }\n    return false\n}\n\nexport const blockNode = (node,blockingType) => {\n    const parent = node.parentElement\n    if (!parent)\n        return false\n    backupScripts.blacklisted.push([node.cloneNode(true),parent])\n    if (blockingType === true || blockingType === 'remove'){\n        parent.removeChild(node)\n        return true\n    }\n    return blockNodeNoBackup(node,blockingType)\n}\n\nfunction replacer(key, value) {\n    if (value instanceof RegExp)\n      return (\"__REGEXP \" + value.toString());\n    else\n      return value;\n  }\n  \n  function reviver(key, value) {\n    if (value.toString().indexOf(\"__REGEXP \") == 0) {\n      var m = value.split(\"__REGEXP \")[1].match(/\\/(.*)\\/(.*)?/);\n      return new RegExp(m[1], m[2] || \"\");\n    } else\n      return value;\n  }\n\n","import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isUrl = pattern => {\n    return pattern.startsWith('http') || pattern.slice(-1) != '/'\n} \n\n/*\n* pattern: tagName:attribute/expresion/blockingType\n* node: an html node or a string with an url or a string to evaluate pattern: tagName:attribute/expresion/ \n*       (las expression must end on /) \n*/\nexport const testPattern = (pattern,node) => {\n    if(typeof node === \"string\"){\n        if ( !node.startsWith('http') && node.slice(-1) == '/' && (node.replace(/\\\\/g,'').match(/\\//g) || []).length == 2){\n            const pos = node.indexOf('/')\n            const posEnd = node.indexOf('/',pos+1)\n            const value = node.substring(pos+1,posEnd-1)\n            let type = 'src'\n            let tagName = 'SCRIPT'\n            if(pos != 0){\n                let arr_type = node.substring(0,pos).split(\":\")\n                if (arr_type.length > 1){\n                    type = arr_type[1]\n                    tagName = arr_type[0].toUpperCase()\n                }else{\n                    type = arr_type[0]\n                } \n            }\n            node = {'tagName': tagName}\n            node[type]=value           \n        }else{\n            node = {'src': node, 'tagName': null}\n        }\n    }\n    if (! (typeof pattern === \"string\")){\n        if (pattern instanceof RegExp && node.tagName === \"SCRIPT\" && node.src)\n            return pattern.test(node.src)\n        else\n            return false\n    }\n    if ((pattern.replace(/\\\\/g,'').match(/\\//g) || []).length != 2)\n        return false\n    const pos = pattern.indexOf('/')\n    const posEnd = pattern.indexOf('/',pos+1)\n    let blockingType = pattern.substring(posEnd+1)    \n    let type = 'src'\n    let tagName = null\n    if(pos != 0){\n        let arr_type = pattern.substring(0,pos).split(\":\")\n        if (arr_type.length > 1){\n            type = arr_type[1]\n            tagName = arr_type[0].toUpperCase()\n        }else{\n            type = arr_type[0]\n        }\n    }\n    if (tagName && node.tagName && tagName !== node.tagName) return false;\n    if (blockingType.length < 1 )\n        blockingType = true\n    pattern = pattern.substring(pos,posEnd+1)\n    if (!node[type]){\n        if (pattern == '//') return blockingType\n        else return false\n    }\n    if (pattern == '//') return false\n    return eval(pattern).test(node[type]) ? blockingType : false\n}\n/*\n*   blockingType\n*   Returns false if not blocked, true if default blocking type (delete node),or blocking type in rule\n*   whith '//' pattern can block local scripts:\n*   - false\n*   - true or remove\n*   - attribute:value\n*   - javascript:function whith node as parameter\n*/\nexport const isOnBlacklist = (node) => {\n    let blockingType = false\n   \n    if (patterns.blacklist){\n        blockingType =  patterns.blacklist.some(pattern => testPattern(pattern,node))\n    }\n\n    if (patterns.whitelist){\n        let doBlocking =  patterns.whitelist.every(pattern => !testPattern(pattern,node))\n\n        //default action block all scripts not whitelisted      \n        // if (blockingType === false && node.tagName && node.tagName === 'SCRIPT' && node.src)\n        //     blockingType = true\n        blockingType = doBlocking ? blockingType: false\n    }    \n    if (node.type && node.type === TYPE_ATTRIBUTE)\n        blockingType = blockingType ? blockingType: true\n    return blockingType\n\n}\n\nexport const willBeUnblocked = function(node) {\n    let blockingType = false\n\n    if (!patterns.blacklist || patterns.blacklist == false)\n        return true\n    // if (patterns.blacklist){\n    //     blockingType =  patterns.blacklist.every(pattern => !testPattern(pattern,node))\n    // }\n    //if not in blacklist must be unblocked\n    if (patterns.whitelist){\n        blockingType =  patterns.whitelist.some(pattern => testPattern(pattern,node))\n    }    \n\n    return blockingType\n}","import { backupScripts, blockNode, TYPE_ATTRIBUTE, blockNodeNoBackup } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    mutations.forEach(({ addedNodes }) => {\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 ){\n                const blockingType = isOnBlacklist(node)                 \n                if (node.tagName === 'SCRIPT' && blockingType) {\n                    // If the src is inside the blacklist and is not inside the whitelist\n                        // We backup a copy of the script node\n                        backupScripts.blacklisted.push([node.cloneNode(true),node.parentElement])\n                        blockNodeNoBackup(node,blockingType)\n                        // Blocks inline script execution in Safari & Chrome\n                        node.type = TYPE_ATTRIBUTE\n\n                        // Firefox has this additional event which prevents scripts from beeing executed\n                        const beforeScriptExecuteListener = function (event) {\n                            // Prevent only marked scripts from executing\n                            if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                                event.preventDefault()\n                            node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                        }\n                        node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                        \n                        node.parentElement.removeChild(node)\n                }\n                else if (blockingType) {\n                    // Remove the node from the DOM\n                    blockNode(node,blockingType)\n                }\n                // if(node.nodeType === 1 && node.tagName === 'IFRAME' && TYPE_SANDBOX !== false) {\n                //     const src = node.src\n                //     // If the src is inside the blacklist and is not inside the whitelist\n                //     if(isOnBlacklist(src)) {\n                //         // We backup a copy of the script node\n                //         //backupIframes.blacklisted.push(node.cloneNode(true))\n\n                //         if (TYPE_SANDBOX === 'remove'){\n                //             // Remove the node from the DOM\n                //             node.parentElement.removeChild(node)\n                //         }else{\n                //             node.sandbox = TYPE_SANDBOX\n                //         }\n                //     }\n                // }  \n            }          \n        }\n    })\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","import { TYPE_ATTRIBUTE, blockNodeNoBackup, patterns } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst originalDescriptors = {\n    src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n    type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n}\nconst createElementBackup = document.createElement\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n\n    const tag = args[0].toLowerCase() \n    const nodeElt = createElementBackup.bind(document)(...args)\n\n    if(tag === 'script'){\n        // Use the prototype descriptors\n            Object.defineProperties(nodeElt, {\n                'src': {\n                    get() {\n                        return originalDescriptors.src.get.call(this)\n                    },\n                    set(value) {\n                        if(isOnBlacklist({'src':value,'type':nodeElt.type,'tagName': 'SCRIPT'})) {\n                            nodeElt.backup_type = nodeElt.type\n                            nodeElt.type = TYPE_ATTRIBUTE\n                        }\n                        return originalDescriptors.src.set.call(this, value)\n                    }\n                },\n                'type': {\n                    set(value) {\n                        const blockingType = isOnBlacklist(nodeElt)\n                        if (blockingType) nodeElt.backup_type = value\n                        return originalDescriptors.type.set.call(\n                            this,\n                            blockingType ?\n                                TYPE_ATTRIBUTE :\n                                value\n                        )\n                    }\n                }\n            })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        nodeElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src')\n                nodeElt[name] = value\n            else\n                HTMLScriptElement.prototype.setAttribute.call(nodeElt, name, value)\n        }\n\n    }   \n\n    //monkey patching cannot remove elements only change attributes\n    if (patterns.tags.some(element => (tag === element[0]))){\n        let props={\n            'type': {\n                set(value) {\n                    if(isOnBlacklist(nodeElt)) {\n                        nodeElt.backup_type = value\n                        value = TYPE_ATTRIBUTE\n                    }                    \n                    return originalDescriptors.type.set.call(this,value)\n                }\n            }            \n         }\n        props[patterns.tags[tag]]={\n                get() {\n                    return originalDescriptors.src.get.call(this)\n                },\n                set(value) {\n                    const blockingType = isOnBlacklist(nodeElt)\n                    if(blockingType) {\n                        value = blockNodeNoBackup(nodeElt,blockingType,patterns.tags[tag])\n                    }\n                    return originalDescriptors.src.set.call(this, value)\n                }\n        }\n        Object.defineProperties(nodeElt, props)\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        nodeElt.setAttribute = function(name, value) {\n            if(name === tag || name === 'type')\n                nodeElt[name] = value\n            else\n                HTMLScriptElement.prototype.setAttribute.call(nodeElt, name, value)\n        }        \n    }\n    \n    return nodeElt\n}","import {\n    patterns,\n    backupScripts,\n    TYPE_ATTRIBUTE,\n    patternsObj,\n    jsonStringify\n} from './variables'\n\nimport {\n    willBeUnblocked,\n    testPattern\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\nexport const unblockId = function(...scriptIds) {\n    scriptIds.forEach((e) => {\n        if (patternsObj.blacklist instanceof Object){\n            try{\n                unblock(patternsObj.blacklist[e]);\n            }catch(_){  /* do nothing*/     }\n        }\n        if (patternsObj.whitelist instanceof Object){\n            try{\n                unblock(patternsObj.whitelist[e]);\n            }catch(_){ /* do nothing*/  }\n        }        \n    });\n}\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrls) {\n\n    if(scriptUrls.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = [ 'type/javascript\\\\/blocked/' ]\n    } else {\n        if(patterns.blacklist instanceof Array) {\n            patterns.blacklist = patterns.blacklist.filter(pattern => \n                scriptUrls.every(url => {\n                    if (url == pattern) return false   \n                    return typeof url == 'string' ? !testPattern(pattern,url): false\n                }))\n            // patterns.blacklist = patterns.blacklist.filter(pattern =>\n            //     scriptUrls.every(url => (typeof url == 'string' ? !testPattern(pattern,url): false ))\n            // )\n        }\n        if (!patterns.whitelist) patterns.whitelist = []\n        if(patterns.whitelist instanceof Array) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrls\n                    .map(url => {\n                        if ( url === true)\n                            url = new RegExp('^$')\n                        if (typeof url == 'string'){\n                            if ( url == '' || url == '//'){\n                                url = new RegExp('^$')\n                        }else if (!( !url.startsWith('http') && url.slice(-1) == '/' && (url.replace(/\\\\/g,'').match(/\\//g) || []).length == 2)){\n                                const escapedUrl = url.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                                url = '/.*' + escapedUrl + '.*/'\n                            }\n                        }\n                        if(!patterns.whitelist.find(p => p.toString() === url.toString())) {\n                            return url\n                        }                        \n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n    // Parse existing script tags with a marked type\n    // We must delete the scripts to make the browser execute it again\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < tags.length; i++) {\n        const script = tags[i]\n        if(willBeUnblocked(script)) {\n            script.setAttribute('type', 'application/javascript')\n            backupScripts.blacklisted.push([script,script.parentElement])\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupScripts.blacklisted].forEach((arr, index) => {\n        let script = arr[0]\n        let parent = arr[1]\n        if(willBeUnblocked(script)) {\n            if (script.type && script.type === TYPE_ATTRIBUTE && script.backup_type)\n                script.setAttribute('type', script.backup_type)\n            if(script.type === 'javascript/blocked')\n                script.setAttribute('type', 'application/javascript')\n            if(script.tagName == 'SCRIPT' && script.src){\n                let s = document.createElement('SCRIPT')\n                s.setAttribute('src', script.src)\n                s.setAttribute('type', 'application/javascript')\n                script = s\n            }\n            parent.appendChild(script)\n            backupScripts.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })    \n\n    //Store filters for next session, with patch to support Regex\n    window.localStorage.YETT_BLACKLIST = jsonStringify( patterns.blacklist)\n    window.localStorage.YETT_WHITELIST = jsonStringify( patterns.whitelist)\n    // document.head.appendChild(script)\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(!patterns.blacklist || (patterns.blacklist && patterns.blacklist.length < 1)) {\n        observer.disconnect()\n    }\n}\n\n\nexport const block = function(...scriptUrls) {\n\n    if(patterns.whitelist instanceof Array) {\n        patterns.whitelist = patterns.whitelist.filter(pattern => \n            scriptUrls.every(url => {\n                if (url == pattern) return false   \n                return typeof url == 'string' ? !testPattern(pattern,url): false\n            }))\n        // patterns.blacklist = patterns.blacklist.filter(pattern =>\n        //     scriptUrls.every(url => (typeof url == 'string' ? !testPattern(pattern,url): false ))\n        // )\n    }\n    if (!patterns.blacklist) patterns.blacklist = []\n    patterns.blacklist = [\n        ...patterns.blacklist,\n        ...scriptUrls\n            .map(url => {\n                if (typeof url == 'string'){\n                    if ( url == '' || url == '//'){\n                        url = new RegExp('^$')\n                }else if (!( !url.startsWith('http') && url.slice(-1) == '/' && (url.replace(/\\\\/g,'').match(/\\//g) || []).length == 2)){\n                        const escapedUrl = url.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                        url = '/.*' + escapedUrl + '.*/'\n                    }\n                }                \n                if(!patterns.blacklist.find(p => p.toString() === url.toString())) {\n                    return url\n                }        \n                return null         \n            }).filter(Boolean)\n    ]\n    window.localStorage.YETT_BLACKLIST = jsonStringify( patterns.blacklist)\n    window.localStorage.YETT_WHITELIST = jsonStringify( patterns.whitelist)    \n}"],"names":["TYPE_ATTRIBUTE","jsonStringify","JSON","stringify","value","replacer","jsonParse","parse","reviver","patternsObj","patterns","window","localStorage","YETT_BLACKLIST","YETT_WHITELIST","blacklist","Array","Object","values","whitelist","forEach","element","pos","indexOf","tag","substring","length","tags","push","backupScripts","blockNodeNoBackup","node","blockingType","attribute","arr","split","type","startsWith","blockNode","parent","parentElement","blacklisted","cloneNode","removeChild","key","RegExp","toString","m","match","testPattern","pattern","slice","replace","src","tagName","posEnd","arr_type","toUpperCase","test","eval","isOnBlacklist","some","every","willBeUnblocked","observer","MutationObserver","addedNodes","i","nodeType","addEventListener","beforeScriptExecuteListener","event","getAttribute","preventDefault","removeEventListener","observe","document","documentElement","originalDescriptors","getOwnPropertyDescriptor","HTMLScriptElement","prototype","createElementBackup","createElement","args","toLowerCase","nodeElt","bind","defineProperties","get","call","this","backup_type","set","setAttribute","name","props","URL_REPLACER_REGEXP","unblockId","scriptIds","e","_","unblock","scriptUrls","filter","url","map","escapedUrl","find","p","Boolean","querySelectorAll","script","indexOffset","index","s","appendChild","splice","disconnect","block"],"mappings":"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"}